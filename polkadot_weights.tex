\documentclass[11pt,a4paper]{article}
\usepackage{geometry}
\geometry{
    a4paper,
    total={170mm,257mm},
    left=20mm,
    top=20mm,
}
\usepackage{color}
\PassOptionsToPackage{hyphens}{url}\usepackage{hyperref}
\usepackage{amsmath}
\usepackage[ruled,vlined]{algorithm2e}
\setlength\parindent{0pt}
\newcommand{\todo}[1]{\textcolor{red}{TODO: #1}}
\newcommand{\SubItem}[1]{
    {\setlength\itemindent{15pt} \item[-] #1}
}

\begin{document}
\title{Polkadot Weights}
\author{Web3 Foundation}
\date{April 2020}
\maketitle

\section{Motivation}
Polkadot has a limited time window for block producers to create a block,
including limitations on block size which can make the selection and execution
of certain extrinsics too expensive and decelerate the network. The weight
system introduces a mechanism for block producers to measure the expense of
extrinsics and determine how "heavy" it is. With this mechanism, block producers
can select a set of extrinsics and saturate the block to it's fullest potential
without exceeding any limitations (as described in section \ref{sec:limitations}).
\newline

Polkadot also introduces a specified block ratio (as defined in section \ref{sec:limitations}),
ensuring that only a certain portion of the total block size gets used for regular extrinsics.
The remaining space is reserved for critical, operational extrinsics required for the functionality
by Polkadot itself.

\section{Fundamentals}
Weights are just a numeric value and Runtime functions may use complex structures to express those
values. Therefore, the following requirements must apply for implementing weight calculations:
\begin{itemize}
\item Computations of weights must be determined before execution of that extrinsic.
\item Due to the limited time window, computations of weights must be done quickly and consume
      few resources themselves.
\item Weights must be self contained and must not require I/O on the chain state. Weights are
      fixed measurements and are based solely on the Runtime function and its parameters.
\item Weights serve three functions: measurements used to calculate transaction fees, to prevent
      the block being filled with too many extrinsics and to avoid extrinsics where its execution
      takes too long.
\end{itemize}

\section{Limitations}\label{sec:limitations}
The assigned weights should be relative to each others execution time and "heaviness",
although weights can be assigned depending on the priorities the chain is supposed to endorse.
Following limitations must be considered when assigning weights, which vary on the Runtime.

\subsection{Considerable limitations}
\begin{itemize}
\item Maximum block length
\item Maximum block weight
\item Targeted time per block
\item Available block ration reserved for normal, none-operational transactions
\end{itemize}

\subsection{Considerable limitations in Polkadot}
As of the official Polkadot Runtime, the limitations are set as follows:

\begin{itemize}
\item Maximum block length: $5 \times 1'024 \times 1'024 = 5'242'880$ Bytes
\item Maximum block weight: 2'000'000'000'000
\item Targeted time per block: 6 seconds
\item Available block ratio: 75\%
\end{itemize}

The values of the assigned weight itself is not relevant. It must only fulfill the requirements
as noted by the fundamentals and limitations, and can be assigned as the author sees fit.
As a simple example, consider a maximum block weight of 1'000'000'000, an available ratio of
75\% and a targeted transaction throughput of 500 transactions, we could assign the weight
for each transaction at about 1'500'000.
\newline

Do note that the smallest, non-zero weight in Polkadot is set at 10'000.

\section{Weight Assignment}
Assigning weights based on theoretical performance such as big O notation proves to be
unreliable and too complex due to imprecision in back-end systems, internal communication
within the Runtime and design choices in the software. Therefore, all available Runtime 
functions, which create and execute extrinsics, have to be benchmarked with a large
collection of input parameters.

\subsection{Parameters}
The inputs parameters highly vary depending on the Runtime function and must therefore
be carefully selected. The benchmarks should use input parameters which will most likely be
used in regular cases, as intended by the authors, but must also consider worst case
scenarios and inputs which might decelerate or heavily impact performance of the function.
The input parameters should be randomized in order to cause various effects in behaviors
on certain values, such as memory relocations and other outcomes that can impact performance.
\newline

It's not possible to benchmark every single value. However, one should select a range
of inputs to benchmark, spanning from very small values (or none, if the Runtime function
allows it) to large values which will most likely exceed the expected usage of that function.
As an example, considering a Runtime function which transfers balances to one or multiple
accounts, one could select a range spanning from very small balances being sent from one to
hundreds of accounts, to very large balances being sent from one to hundreds of accounts.
\newline

The benchmarks should run individual executions/iterations within that range, where the chosen parameters
should give insight on an average execution time and resource cost. Selecting imprecise parameters
or too extreme ranges might indicate an inaccurate average of the function as it will be used in production.
Therefore, when a range of input parameters gets benchmarked, the result of each individual parameter
should be recorded and ideally visualized. The author should then decide on the most probable average
execution time, basing that decision on the limitations of the Runtime and expected usage of the network.
\newline

Additionally, given the distinction between theory and practice, the author reserves the right
to make adjustments to the input parameters and assigned weights according to observed behavior
of the actual, real-world network.

\subsection{Blockchain State}
The benchmarks should be performed on blockchain states that already polluted and contain a history of
extrinsics and storage changes. Runtime functions that require I/O on structures
such as Tries will therefore produce more realistic results that will reflect the real-world
performance of the Runtime.

\subsection{Environment}
The benchmarks should be executed on clean systems without interference of other processes
or software. Additionally, the benchmarks should be executed multiple machines with different
system resources, such as CPU performance, CPU cores, RAM and storage speed.

\subsection{Runtime Analysis}
The Runtime functions must be studied in order to determine which parts of the code will excessively
increase execution time. Potential indicators like loops, IO operations and data manipulation must
be considered. Based on those observations, one should then select parameters that could have heavy
implications on those design decisions.

\subsection*{Practical example \#1}

\subsubsection*{Analysis}

In Polkadot, Controller accounts can save information about themselves onchain, known as the "Identity Info".
This includes information such as display name, legal name, email address, and so on. Polkadot selects
a set of registrar which can judge identities and therefore incentivizes a reputation model. The judgement itself
is done offchain. The registrars rating, however, is saved onchain, directly in the corresponding 
Identity Info. It's also note worthy that Identiy Info can contain additional fields, set manually by account
holder.
\newline

The function \verb|request_judgement| from the \verb|identity| Pallet allows users to request a judgement
from a specific registrar. Studying this function reveals multiple design choices that can impact performance.
\newline

First, it fetches a list of current registrars from storage and then searches that list for the specified
registrar index.

\begin{verbatim}
let registrars = <Registrars<T>>::get();
let registrar = registrars.get(reg_index as usize).and_then(Option::as_ref)
  .ok_or(Error::<T>::EmptyIndex)?;
\end{verbatim}

Then, it searches for the Identity Info from storage, based on the sender of the transaction.

\begin{verbatim}
let mut id = <IdentityOf<T>>::get(&sender).ok_or(Error::<T>::NoIdentity)?;
\end{verbatim}

The Identity Info contains the entirety of entries, in an ordered form. It then proceeds the search all
those entries for the specified registrar index. If an entry can be found, the value is updated
(assuming the registrar is not "stickied", which implies it cannot be changed). In the context of registrars,
this update implies that the Identity Info should be rejudged. If the entry cannot 
be found, the value is inserted into the index where a matching element could be inserted while maintaining
sorted order. This results in memory reallocation.
\newpage

\begin{verbatim}
match id.judgements.binary_search_by_key(&reg_index, |x| x.0) {
  Ok(i) => if id.judgements[i].1.is_sticky() {
    Err(Error::<T>::StickyJudgement)?
  } else {
    id.judgements[i] = item
  },
  Err(i) => id.judgements.insert(i, item),
}
\end{verbatim}

After that, it proceeds to reserve the registrar fee, inserts the newly updated identity info into storage
and deposits the event into the scheduler.

\begin{verbatim}
T::Currency::reserve(&sender, registrar.fee)?;
<IdentityOf<T>>::insert(&sender, id);
Self::deposit_event(RawEvent::JudgementRequested(sender, reg_index));
\end{verbatim}

\subsubsection*{Considerations}

Based on this analysis, the following conclusions can be drawn:

\begin{itemize}
  \item The list of registrars varies. Fetching and searching through it can impact execution time.
  Given that only one operation is required to fetch the account, no matter the input, a too excessive
  deviation is not to be expected.
  \SubItem{The benchmarks should be executed with different list sizes, from only a few to many registrars.}
  \item The specified sender of the transaction is fetched from storage. Depending on the total accounts
  available in the storage, the execution time can vary. Given that only one operation is required to fetch
  the account, no matter the input, a too excessive deviation is not to be expected.
  \SubItem{The benchmarks should be executed with a different amount of preexisting accounts in storage.}
  \item The specified registrar is searched for in the Identity Info. Additionally, if a new value gets
  inserted into the byte array, memory get reallocated. Depending on the size of the Identity Info, the
  execution time can vary.
  \SubItem{The benchmarks should be executed with different sizes of the Identity Info, including
  additional fields.}
  \SubItem{The benchmarks should request judgement from registrars that are already inserted in the Identity
  Info and newly introduced ones, in order to trigger memory reallocation.}
  \SubItem{It is legitimate to introduce additional Weights for changes the sender has influence over,
  such the additional fields in Identity Info.}
  \item Reserving a balance, inserting the Identity Info back to storage and creating a deposit event is
  unlikely to differ among benchmark varieties, besides for the thing already covered above.
\end{itemize}

\subsection{Preliminary Work}
In order for certain benchmarks to produce conditions where resource heavy computation or excessive
I/O can be observed, the benchmarks might require some preliminary work on the environment, since those
conditions cannot be created with simply selected parameters.
As practical examples, this section describes the specifically designed benchmarks for the \verb|transfer|
and \verb|withdraw_unbonded| functions available in the Polkadot Runtime.

\subsubsection{Practical example \#1}
The $transfer$ function of the \textit{balances} module is designed to move the specified balance by the sender to the receiver.
The benchmark is configured to measure the function's worst possible condition:

\begin{itemize}
  \item Transfer will kill the sender account (by completely depleting the balance to zero).
  \item Transfer will create the recipient account (the recipient account doesn't have a balance yet).
\end{itemize}

\subsubsection*{Parameters}
The following parameters are selected:

\begin{center}
  \begin{tabular}{ l|r l l l }
    \textbf{Type} && \textbf{From} & \textbf{To} & \textbf{Description}\\
    \hline
    Account index & \verb|index| in... & 1 & 1000 & Used as a seed for account creation \\
    Balance & \verb|balance| in... & 2 & 1000 & Sender balance and transfer amount \\
  \end{tabular}
\end{center}

Executing a benchmark for each balance increment within the balance range for each index increment
within the index range will generate too many variants ($1000 \times 999$) and highly increase
execution time. Therefore, this benchmark is configured to first set the balance at value 1'000
and then to iterate from 1 to 1'000 for the index value. Once the index value reaches 1'000, the
balance value will reset to 2 and iterate to 1'000 (see algorithm \ref{sec:algo-benchmark-transfer}
for more detail):

\begin{itemize}
  \item \verb|index|: 1, \verb|balance|: 1000
  \item \verb|index|: 2, \verb|balance|: 1000
  \item \verb|index|: 3, \verb|balance|: 1000
  \item ...
  \item \verb|index|: 1000, \verb|balance|: 1000
  \item \verb|index|: 1000, \verb|balance|: 2
  \item \verb|index|: 1000, \verb|balance|: 3
  \item \verb|index|: 1000, \verb|balance|: 4
  \item ...
\end{itemize}

The parameters itself do not influence or trigger the two worst conditions and must be handled by
the implemented benchmarking tool. The $transfer$ benchmark is implemented as defined in algorithm
\ref{sec:algo-benchmark-transfer}.

\subsubsection*{Implementation}
The benchmarking implementation for the Polkadot Runtime function $transfer$ is defined as
follows (starting with the \textsc{Main} function):
\newline

\SetKw{KwInit}{Init:}
\SetKw{KwBy}{increment by}
\SetKwProg{Fn}{Function}{ is}{end}

\begin{algorithm}[H]\label{sec:algo-benchmark-transfer}
  \caption{Run multiple benchmark iterations for $transfer$ Runtime function}
  \SetAlgoLined
  \KwResult{$collection$: a collection of time measurements of all benchmark iterations}
  \BlankLine
  \Fn{\textsc{Main}}{
    \KwInit{collection = \{\}\;}
    \KwInit{$balance = 1'000$\;}
    \For{$index\gets1$ \KwTo $1'000$ \KwBy $1$}{
      $time \leftarrow$ \textsc{Run-Benchmark($index$, $balance$)}\;
      \textsc{Add-To($collection$, $time$)}\;
    }
    \BlankLine
    \KwInit{$index = 1'000$\;}
    \For{$balance\gets2$ \KwTo $1'000$ \KwBy $1$}{
      $time \leftarrow$ \textsc{Run-Benchmark($index$, $balance$)}\;
      \textsc{Add-To($collection$, $time$)}\;
    }
  }
  \BlankLine
  \Fn{\textsc{Run-Benchmark($index$, $balance$)}}{
    $sender \leftarrow$ \textsc{Create-Account(\textit{"caller"}, $index$)}\;
    $recipient \leftarrow$ \textsc{Create-Account(\textit{"recipient"}, $index$)}\;
    \textsc{Set-Balance($sender$, $balance$)}\;
    \BlankLine
    $time \leftarrow$\textsc{Timer(Transfer($sender$, $recipient$, $balance$))}\;
    \Return $time$
  }
\end{algorithm}

\begin{itemize}
  \item \textsc{Create-Account($name$, $index$)}
      \SubItem{Creates a Blake2 hash of the concatenated input of $name$ and $index$ representing
      the address of a account. This function only creates an address and does not conduct any I/O.}
  \item \textsc{Set-Balance($account$, $balance$)}
      \SubItem{Sets a initial $balance$ for the specified $account$ in the storage state.}
  \item \textsc{Transfer($sender$, $recipient$, $balance$)}
      \SubItem{Transfers the specified $balance$ from $sender$ to $recipient$ by calling the
      corresponding Runtime function. This represents the target Runtime function to be benchmarked.}
  \item \textsc{Add-To($collection$, $time$)}
      \SubItem{Adds a returned time measurement ($time$) to $collection$.}
  \item \textsc{Timer($function$)}
      \SubItem{Measures the time from the start of the specified $function$ to its completion.}
\end{itemize}

\newpage
\subsubsection{Practical example \#2}
The $withdraw\_unbonded$ function of the \textit{staking} module is designed to move any unlocked
funds from the staking management system to be ready for transfer. The benchmark requires a couple
of I/O operations:

\begin{itemize}
  \item Create stash account and set initial balance.
  \item Create controller account and set initial balance.
  \item Bond a certain amount of the funds.
  \item Unbond full amount of the funds.
  \item Withdraw unbonded amount, making it ready for transfer.
\end{itemize}

\subsubsection*{Parameters}
The following parameters are selected:

\begin{center}
  \begin{tabular}{ l|r l l l }
    \textbf{Type} && \textbf{From} & \textbf{To} & \textbf{Description}\\
    \hline
    Account index & \verb|index| in... & 0 & 1000 & Used as a seed for account creation \\
  \end{tabular}
\end{center}

This benchmark does not require complex parameters. The values is use solely for account generation.

\subsubsection*{Implementation}
The benchmarking implementation for the Polkadot Runtime function $withdraw\_unbonded$ is defined as follows:
\newline

\SetKw{KwInit}{Init:}
\SetKw{KwBy}{increment by}
\SetKwProg{Fn}{Function}{ is}{end}

\begin{algorithm}[H]\label{sec:algo-benchmark-transfer}
  \caption{Run multiple benchmark iterations for $transfer$ Runtime function}
  \SetAlgoLined
  \KwResult{$collection$: a collection of time measurements of all benchmark iterations}
  \BlankLine
  \Fn{\textsc{Main}}{
    \KwInit{collection = \{\}\;}
    \For{$index\gets0$ \KwTo $1'000$ \KwBy $1$}{
      $stash \leftarrow$ \textsc{Create-Account(\textit{"stash"}, $index$)}\;
      $controller \leftarrow$ \textsc{Create-Account(\textit{"controller"}, $index$)}\;
      \textsc{Set-Balance($stash$, 100)}\;
      \textsc{Set-Balance($controller$, 100)}\;
      \textsc{Bond($stash$, $controller$, 10)}\;
      \textsc{UnBond($controller$, 10)}\;
      $time \leftarrow$\textsc{Timer(Withdraw-Unbonded($controller$))}\;
      \textsc{Add-To($collection$, $time$)}\;
    }
  }
  \BlankLine
\end{algorithm}

\begin{itemize}
  \item \textsc{Create-Account($name$, $index$)}
    \SubItem{Creates a Blake2 hash of the concatenated input of $name$ and $index$ representing
    the address of a account. This function only creates an address and does not conduct any I/O.}
  \item \textsc{Set-Balance($account$, $balance$)}
      \SubItem{Sets a initial $balance$ for the specified $account$ in the storage state.}
  \item \textsc{Bond($stash$, $controller$, $amount$)}
    \SubItem{Bonds the specified $amount$ for the $stash$ and $controller$ pair.}
  \item \textsc{UnBond($account$, $amount$)}
    \SubItem{Unbonds the specified $amount$ for the given $account$.}
  \item \textsc{Withdraw-Unbonded($controller$)}
    \SubItem{Withdraws the the full unbonded amount of the specified $controller$ account.
    This represents the target Runtime function to be benchmarked}
  \item \textsc{Add-To($collection$, $time$)}
    \SubItem{Adds a returned time measurement ($time$) to $collection$.}
  \item \textsc{Timer($function$)}
    \SubItem{Measures the time from the start of the specified $function$ to its completion.}
\end{itemize}

\section{Fees}
Block producers charge a fee in order to be economically sustainable. That fee must always
be covered by the sender of the transaction. Polkadot has a flexible mechanism to determine
the minimum cost to include transactions in a block.

\subsection{Fee Calculation}
Polkadot fees consists of three parts:

\begin{itemize}
\item Base fee: a fixed fee that is applied to every transaction and set by the Runtime.
\item Length fee: a fee that gets multiplied by the length of the transaction, in bytes.
\item Weight fee: a fee for each, varying Runtime function. Runtime implementers need to
      implement a conversion mechanism which determines the corresponding currency amount
      for the calculated weight.
\end{itemize}

The final fee can be summarized as:
\begin{eqnarray*}
\lefteqn{fee = base\ fee}\\
      &&{} + length\ of\ transaction\ in\ bytes \times length\ fee\\
      &&{} + weight\ to\ fee\\
\end{eqnarray*}

\subsection{Definitions in Polkadot}
The Polkadot Runtime defines the following values:
\begin{itemize}
\item Base fee: 100 uDOTs
\item Length fee: 0.1 uDOTs
\item Weight to fee conversion:
      $$
            weight\ fee = weight \times (100\ uDOTs \div (10 \times 10'000))
      $$
      A weight of 10'000 (the smallest non-zero weight) is mapped to $\frac{1}{10}$ of 100 uDOT.
      \newline
      This fee will never exceed the max size of an unsigned 128 bit integer.
\end{itemize}

\subsection{Fee Multiplier}
Polkadot can add a additional fee to transactions if the network becomes too busy and starts to
decelerate the system. This fees can create incentive to avoid the production of
low priority or insignificant transactions. In contrast, those additional fees will decrease if
the network calms down and it can execute transactions without much difficulties.
\newline

That additional fee is known as the \verb|Fee Multiplier| and its value is defined
by the Polkadot Runtime. The multiplier works by comparing the saturation of blocks; if the previous 
block is less saturated than the current block (implying an uptrend), the fee is slightly increased.
Similarly, if the previous block is more saturated than the current block (implying a downtrend), the
fee is slightly decreased.
\newline

The final fee is calculated as:
$$
      final\ fee = fee \times Fee\ Multiplier
$$

\subsubsection{Update Multiplier}
The \verb|Update Multiplier| defines how the multiplier can change. The Polkadot Runtime internally
updates the multiplier after each block according the following formula:

\begin{eqnarray*}
diff &=& (target\ weight - previous\ block\ weight)\\
v &=& 0.00004\\
next\ weight &=& weight \times (1 + (v \times diff) + (v \times diff)^2 / 2)\\
\end{eqnarray*}

Polkadot defines the \verb|target_weight| as 0.25 (25\%). More information about this algorithm is described
in the Web3 Foundation research paper: \url{https://research.web3.foundation/en/latest/polkadot/Token%20Economics.html#relay-chain-transaction-fees-and-per-block-transaction-limits}.

\end{document}
